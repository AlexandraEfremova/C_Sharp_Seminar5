// Задайте двумерный массив. Найдите сумму элементов,
// находящихся на главной диагонали (с индексами (0, 0); (1, 1) и т.д.)
// Пример:
// 2 3 4 3
// 4 3 4 2     =>  2 + 3 + 5 = 10
// 2 9 5 4 

void Main()
{
    int row = ReadInt("Введите количество строк: ");
    int col = ReadInt("Введите количество колонок: ");
    int[,] matrix = GenereateMatrix(row, col, 0, 99);
    PrintMatrix(matrix);
    System.Console.WriteLine(SumOnMainDiagonal(matrix));
}

// напишем функцию для поиска суммы элементов
int SumOnMainDiagonal(int[,] matrix)
{
    int sum = 0;
    // чтобы е получить ошибку добавим условие того, что наша переменная счётчик
    // будет повышаться до тех пор пока меньше количества строк, 
    // а так же она должна быть меньше количества столбцов.
    // так же данную строку - matrix.GetLength(0) && i < matrix.GetLength(1) - можно вывести
    // в отдельную переменную, которая будет высчитывать, что меньше, количество
    // строк и столбцов и тем самым разгрузит нашу программу
    // метод Math.Min - принимает на вход аргументы и возвращает меньшее из них
    int iterCount = Math.Min(matrix.GetLength(0), matrix.GetLength(1));
    for (int i = 0; i < iterCount; i++)
    {
        sum += matrix[i, i];
        // for (int j = 0; j < matrix.GetLength(1); j++)
        // {
            // фактически мы будем проверять на равенство индексы строк и столбцов и 
            // Если они равны, то к сумме будем прибавлять значение под этими индексами
            // однако такая вариация кода будет очень нагромождённой, так как при большом
            // количестве элементов в массиве нужно будет делать большое количество проверок
            // тем самым замедлится работа кода. В таком случае мы можем его сократить
            // не будем использовать два счётчика, а используем только 1 - i. 
            // Так как оба индекса всегда одинаковы. В таком случае переменную счётчик мы так
            // же убираем, так как нам нужен только один индекс
            // if(i == j)
            // {
            //     sum += matrix[i,j];
            // }

        // }
    }
    return sum;
}

// напишем метод для вывода матрицы
void PrintMatrix(int[,] matrix)
{
    for (int i = 0; i < matrix.GetLength(0); i++)
    {
        for (int j = 0; j < matrix.GetLength(1); j++)
        {
            System.Console.Write(matrix[i, j] + "\t");
        }
        // делаем отступ пустой строкой для более презентабельного вывода двумерной матрицы
        System.Console.WriteLine();
    }
    System.Console.WriteLine();
}

// напишем метод для генерации двумерного массива, в качестве аргумента передалим
// количество строк, количество столбцов, максимальное и минимальное
// значения для генерации мсассива
int[,] GenereateMatrix(int rowSize, int colSize, int minValue, int maxValue)
{
    int[,] tempMatrix = new int[rowSize, colSize];
    // объявляем экзкмпляр класса для экономии оперативной памяти
    Random rand = new Random();

    // задаём цикл для прохода по элементам массива
    // tempMatrix.GetLength(0) - отвечает за количество строк
    for (int i = 0; i < tempMatrix.GetLength(0); i++)
    {
        for (int j = 0; j < tempMatrix.GetLength(1); j++)
        {
            // обращаемся к элементу массива i и j, задаём им рандомное
            // значение rand.Next в диапазоне от minValue до maxValue
            tempMatrix[i, j] = rand.Next(minValue, maxValue + 1);
        }
    }
    return tempMatrix;
}

// напишем функцию, которая принимает от пользователя размер массива и возвращает его
int ReadInt(string msg)
{
    // принимает сообщение для пользователя
    System.Console.Write(msg);
    // возвращает число, введённое пользователем
    return Convert.ToInt32(Console.ReadLine());
}

Main();
